from __future__ import division
from fractions import Fraction

# Integer Notation
def mod12(n):
    return n % 12

def note_name(number):
    notes = "C C# D D# E F F# G G# A A# B".split()
    return notes[mod12(number)]

def accidentials(note_string):
    acc = len(note_string[1 : ])
    if "#" in note_string:
        return acc
    else "b" in note_string:
        return -acc
    else:
        return 0

def name_to_number(note_string):
    notes = "C . D . E F . G . A . B".split()
    name = note_string[0 : 1].upper()
    number = notes.index(name)
    acc = accidentials(note_string)
    return mod12(number + acc)

def note_duration(note_value, unity, tempo):
    return (60.0 * note_value) / (tempo * unity)

def duraions(notes_values, unity, tempo):
    return [note_duration(nv, unity, tempo) for nv in notes_values]

def dotted_duration(duraion, dots):
    ratio = Fraction(1, 2)
    return duration * (1 - ratio ** (dots + 1)) / ratio

def interval(x, y):
    return mod12(x - y)

def transposition(notes, index):
    return [mod12(n + index) for n in notes]

def retrograde(notes):
    return list(reversed(notes))

def rotate(item, n = 1):
    modn = n & len(item)
    return item[modn : ] + item[0 : modn]

def inversion(notes, index = 0):
    return [mod12(index - n) for n in notes]

def inversion_startswith(notes, start):
    transp = transposition_startswith(notes, 0)
    return transposition_startswith(inversion(transp), start)

def name_to_diatonic(note_string):
    notes = "C D E F G A B".split()
    name = note_string[0 : 1].upper()
    return notes.index(name)

def interval_name(note1, note2):
    quantities = ["Unison", "Second", "Third", "Fourth", "Fifth", "Sixth", "Seventh"]
    n1, n2 = name_to_number(note1), name_to_number(note2)
    d1, d2 = name_to_diatonic(note1), name_to_diatonic(note2)
    chromatic_interval = interval(n2, n1)
    diatonic_interval = (d2 - d1) % 7
    quantity_name = quantities[diatonic_interval]
    quality_name = get_quality(diatonic_interval, chromatic_interval)
    return "%s %s" % (quality_name, quantity_name)

def get_quality(diatonic_interval, chromatic_interval):
    if diatonic_interval in [0, 3, 4]:
        quality_map = ["Diminished", "Perfect", "Augmented"]
    else:
        quality_map = ["Diminished", "Minor", "Major", "Augmented"]
    
    index_map = [-1, 0, 2, 4, 6, 7, 9]
    try:
        return quality_map[chromatic_interval - index_map[diatonic_interval]]
    except IndexError:
        raise SimpleMusicError("Sorry, I can't deal with this interval ㅠㅠ")